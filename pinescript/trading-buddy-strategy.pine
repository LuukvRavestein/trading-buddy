//@version=5
strategy("Trading Buddy - Bitcoin Day Trading", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// ============================================================================
// TRADING BUDDY - PINE SCRIPT STRATEGY
// ============================================================================
// This script generates trading signals and sends them to the Trading Buddy
// webhook endpoint via TradingView alerts.
//
// SETUP INSTRUCTIONS:
// 1. Add this script to TradingView chart (BTC-PERPETUAL recommended)
// 2. Configure alerts: Right-click chart > Add Alert
// 3. Condition: "Any alert() function call"
// 4. Webhook URL: https://your-vercel-app.vercel.app/api/webhook
// 5. Message: Use the JSON payload format below (see alert() calls)
// 6. Enable "Webhook URL" option
//
// ============================================================================

// --- INPUTS ---
// Timeframe settings
trendTimeframe = input.timeframe("15", "Trend Timeframe", group="Strategy Settings")
entryTimeframe = input.timeframe("5", "Entry Timeframe", group="Strategy Settings")

// Risk management
stopLossPercent = input.float(0.5, "Stop Loss %", minval=0.1, maxval=2.0, step=0.1, group="Risk Management")
takeProfitPercent = input.float(1.0, "Take Profit %", minval=0.5, maxval=5.0, step=0.1, group="Risk Management")
minRiskReward = input.float(2.0, "Min Risk:Reward Ratio", minval=1.0, maxval=5.0, step=0.1, group="Risk Management")

// Supply/Demand zone settings
zoneLookback = input.int(50, "Zone Lookback Periods", minval=20, maxval=200, group="Zone Detection")
zoneStrength = input.int(3, "Zone Strength (touches)", minval=2, maxval=10, group="Zone Detection")

// Webhook secret (optional, for security)
webhookSecret = input.string("", "Webhook Secret (optional)", group="Webhook Settings")

// --- VARIABLES ---
var string currentTrend = "NEUTRAL"
var float supplyZoneHigh = na
var float supplyZoneLow = na
var float demandZoneHigh = na
var float demandZoneLow = na

// --- TREND DETECTION (15m timeframe) ---
[trendEMA, trendSMA] = request.security(syminfo.tickerid, trendTimeframe, [ta.ema(close, 20), ta.sma(close, 50)], lookahead=barmerge.lookahead_off)

trendUp = trendEMA > trendSMA and close > trendEMA
trendDown = trendEMA < trendSMA and close < trendEMA

if trendUp
    currentTrend := "UP"
else if trendDown
    currentTrend := "DOWN"
else
    currentTrend := "NEUTRAL"

// --- SUPPLY/DEMAND ZONE DETECTION ---
// Simplified zone detection based on price reactions
// TODO: Implement your specific supply/demand zone logic here

// Example: Detect zones based on price wicks and reactions
var float[] supplyZones = array.new<float>()
var float[] demandZones = array.new<float>()

// Detect supply zones (resistance) - price rejected from high
if high[1] > high[2] and high[1] > high and close < open
    array.push(supplyZones, high[1])
    if array.size(supplyZones) > 10
        array.shift(supplyZones)

// Detect demand zones (support) - price rejected from low
if low[1] < low[2] and low[1] < low and close > open
    array.push(demandZones, low[1])
    if array.size(demandZones) > 10
        array.shift(demandZones)

// --- ENTRY SIGNAL DETECTION ---
// Look for retest of supply/demand zones on 5m timeframe
[entryClose, entryHigh, entryLow] = request.security(syminfo.tickerid, entryTimeframe, [close, high, low], lookahead=barmerge.lookahead_off)

bool longSignal = false
bool shortSignal = false
float entryPrice = na
float slPrice = na
float tpPrice = na

// LONG signal: retest of demand zone in uptrend
if currentTrend == "UP" and array.size(demandZones) > 0
    demandLevel = array.get(demandZones, array.size(demandZones) - 1)
    tolerance = demandLevel * 0.001 // 0.1% tolerance
    
    if entryLow <= demandLevel + tolerance and entryLow >= demandLevel - tolerance
        longSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 - stopLossPercent / 100)
        tpPrice := entryPrice * (1 + takeProfitPercent / 100)

// SHORT signal: retest of supply zone in downtrend
if currentTrend == "DOWN" and array.size(supplyZones) > 0
    supplyLevel = array.get(supplyZones, array.size(supplyZones) - 1)
    tolerance = supplyLevel * 0.001 // 0.1% tolerance
    
    if entryHigh >= supplyLevel - tolerance and entryHigh <= supplyLevel + tolerance
        shortSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 + stopLossPercent / 100)
        tpPrice := entryPrice * (1 - takeProfitPercent / 100)

// Validate Risk:Reward ratio
if longSignal or shortSignal
    risk = math.abs(entryPrice - slPrice)
    reward = math.abs(tpPrice - entryPrice)
    rr = reward / risk
    
    if rr < minRiskReward
        longSignal := false
        shortSignal := false

// --- VISUALIZATION ---
plotshape(longSignal, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title="LONG Signal")
plotshape(shortSignal, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="SHORT Signal")

// Plot trend
plot(currentTrend == "UP" ? low : na, color=color.new(color.green, 80), style=plot.style_stepline, linewidth=2, title="Uptrend")
plot(currentTrend == "DOWN" ? high : na, color=color.new(color.red, 80), style=plot.style_stepline, linewidth=2, title="Downtrend")

// --- ALERT LOGIC ---
// Generate webhook payload when signal is detected
if longSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"LONG","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("LONG", strategy.long, comment="LONG")

if shortSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"SHORT","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("SHORT", strategy.short, comment="SHORT")

// --- STRATEGY EXIT (for backtesting) ---
if strategy.position_size > 0
    strategy.exit("LONG EXIT", "LONG", stop=slPrice, limit=tpPrice)

if strategy.position_size < 0
    strategy.exit("SHORT EXIT", "SHORT", stop=slPrice, limit=tpPrice)

// --- TABLE INFO (optional) ---
if barstate.islast
    var table infoTable = table.new(position.top_right, 2, 4, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(infoTable, 0, 0, "Trend", text_color=color.black)
    table.cell(infoTable, 1, 0, currentTrend, text_color=currentTrend == "UP" ? color.green : currentTrend == "DOWN" ? color.red : color.gray)
    table.cell(infoTable, 0, 1, "Entry TF", text_color=color.black)
    table.cell(infoTable, 1, 1, entryTimeframe, text_color=color.black)
    table.cell(infoTable, 0, 2, "SL %", text_color=color.black)
    table.cell(infoTable, 1, 2, str.tostring(stopLossPercent) + "%", text_color=color.black)
    table.cell(infoTable, 0, 3, "TP %", text_color=color.black)
    table.cell(infoTable, 1, 3, str.tostring(takeProfitPercent) + "%", text_color=color.black)

