//@version=5
strategy("Trading Buddy - Bitcoin Day Trading", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// ============================================================================
// TRADING BUDDY - PINE SCRIPT STRATEGY
// ============================================================================
// This script generates trading signals and sends them to the Trading Buddy
// webhook endpoint via TradingView alerts.
//
// SETUP INSTRUCTIONS:
// 1. Add this script to TradingView chart (BTC-PERPETUAL recommended)
// 2. Configure alerts: Right-click chart > Add Alert
// 3. Condition: "Any alert() function call"
// 4. Webhook URL: https://your-vercel-app.vercel.app/api/webhook
// 5. Message: Use the JSON payload format below (see alert() calls)
// 6. Enable "Webhook URL" option
//
// ============================================================================

// --- INPUTS ---
// Timeframe settings
trendTimeframe = input.timeframe("15", "Trend Timeframe", group="Strategy Settings")
entryTimeframe = input.timeframe("5", "Entry Timeframe", group="Strategy Settings")

// Risk management
stopLossPercent = input.float(0.5, "Stop Loss %", minval=0.1, maxval=2.0, step=0.1, group="Risk Management")
takeProfitPercent = input.float(1.0, "Take Profit %", minval=0.5, maxval=5.0, step=0.1, group="Risk Management")
minRiskReward = input.float(2.0, "Min Risk:Reward Ratio", minval=1.0, maxval=5.0, step=0.1, group="Risk Management")

// Supply/Demand zone settings
zoneLookback = input.int(50, "Zone Lookback Periods", minval=20, maxval=200, group="Zone Detection")
zoneStrength = input.int(3, "Zone Strength (touches)", minval=2, maxval=10, group="Zone Detection")

// Webhook secret (optional, for security)
webhookSecret = input.string("", "Webhook Secret (optional)", group="Webhook Settings")

// Test mode (for testing webhook without real signals)
enableTestMode = input.bool(false, "Enable Test Mode", group="Webhook Settings", tooltip="When enabled, sends a test alert every bar to verify webhook is working")

// --- VARIABLES ---
var string currentTrend = "NEUTRAL"
var float supplyZoneHigh = na
var float supplyZoneLow = na
var float demandZoneHigh = na
var float demandZoneLow = na

// --- TREND DETECTION (15m timeframe) ---
[trendEMA, trendSMA] = request.security(syminfo.tickerid, trendTimeframe, [ta.ema(close, 20), ta.sma(close, 50)], lookahead=barmerge.lookahead_off)

trendUp = trendEMA > trendSMA and close > trendEMA
trendDown = trendEMA < trendSMA and close < trendEMA

if trendUp
    currentTrend := "UP"
else if trendDown
    currentTrend := "DOWN"
else
    currentTrend := "NEUTRAL"

// --- SUPPLY/DEMAND ZONE DETECTION ---
// Improved zone detection that keeps zones longer and detects more patterns
var float[] supplyZones = array.new<float>()
var float[] demandZones = array.new<float>()

// Detect supply zones (resistance) - price rejected from high
// Multiple patterns to catch more zones
if high[1] > high[2] and high[1] > high and close < open
    // Strong rejection pattern
    array.push(supplyZones, high[1])
else if high[1] > high and close < open[1] and close < open
    // Rejection with bearish close
    array.push(supplyZones, high[1])
else if high[1] > ta.highest(high, 5) and close < open
    // New high rejection
    array.push(supplyZones, high[1])

// Keep more zones (increased from 10 to 20)
if array.size(supplyZones) > 20
    array.shift(supplyZones)

// Detect demand zones (support) - price rejected from low
// Multiple patterns to catch more zones
if low[1] < low[2] and low[1] < low and close > open
    // Strong bounce pattern
    array.push(demandZones, low[1])
else if low[1] < low and close > open[1] and close > open
    // Bounce with bullish close
    array.push(demandZones, low[1])
else if low[1] < ta.lowest(low, 5) and close > open
    // New low bounce
    array.push(demandZones, low[1])

// Keep more zones (increased from 10 to 20)
if array.size(demandZones) > 20
    array.shift(demandZones)

// --- ENTRY SIGNAL DETECTION ---
// Look for retest of supply/demand zones on 5m timeframe
[entryClose, entryHigh, entryLow] = request.security(syminfo.tickerid, entryTimeframe, [close, high, low], lookahead=barmerge.lookahead_off)

bool longSignal = false
bool shortSignal = false
float entryPrice = na
float slPrice = na
float tpPrice = na

// LONG signal: retest of demand zone in uptrend
// Check last 3 demand zones for retest (balanced approach)
if currentTrend == "UP" and array.size(demandZones) > 0
    // Check most recent zone
    demandLevel = array.get(demandZones, array.size(demandZones) - 1)
    tolerance = demandLevel * 0.003 // 0.3% tolerance (balanced)
    
    // Also check 2nd and 3rd most recent zones
    demandLevel2 = array.size(demandZones) >= 2 ? array.get(demandZones, array.size(demandZones) - 2) : na
    demandLevel3 = array.size(demandZones) >= 3 ? array.get(demandZones, array.size(demandZones) - 3) : na
    
    // Check if price touches zone (using low, close, or high)
    retest1 = entryLow <= demandLevel + tolerance and entryLow >= demandLevel - tolerance
    retest1b = entryClose <= demandLevel + tolerance and entryClose >= demandLevel - tolerance
    retest1c = entryHigh <= demandLevel + tolerance and entryHigh >= demandLevel - tolerance
    
    retest2 = not na(demandLevel2) and (entryLow <= demandLevel2 + tolerance and entryLow >= demandLevel2 - tolerance or entryClose <= demandLevel2 + tolerance and entryClose >= demandLevel2 - tolerance or entryHigh <= demandLevel2 + tolerance and entryHigh >= demandLevel2 - tolerance)
    
    retest3 = not na(demandLevel3) and (entryLow <= demandLevel3 + tolerance and entryLow >= demandLevel3 - tolerance or entryClose <= demandLevel3 + tolerance and entryClose >= demandLevel3 - tolerance or entryHigh <= demandLevel3 + tolerance and entryHigh >= demandLevel3 - tolerance)
    
    if retest1 or retest1b or retest1c or retest2 or retest3
        longSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 - stopLossPercent / 100)
        tpPrice := entryPrice * (1 + takeProfitPercent / 100)

// SHORT signal: retest of supply zone in downtrend
// Check last 3 supply zones for retest (balanced approach)
if currentTrend == "DOWN" and array.size(supplyZones) > 0
    // Check most recent zone
    supplyLevel = array.get(supplyZones, array.size(supplyZones) - 1)
    tolerance = supplyLevel * 0.003 // 0.3% tolerance (balanced)
    
    // Also check 2nd and 3rd most recent zones
    supplyLevel2 = array.size(supplyZones) >= 2 ? array.get(supplyZones, array.size(supplyZones) - 2) : na
    supplyLevel3 = array.size(supplyZones) >= 3 ? array.get(supplyZones, array.size(supplyZones) - 3) : na
    
    // Check if price touches zone (using high, close, or low)
    retest1 = entryHigh >= supplyLevel - tolerance and entryHigh <= supplyLevel + tolerance
    retest1b = entryClose >= supplyLevel - tolerance and entryClose <= supplyLevel + tolerance
    retest1c = entryLow >= supplyLevel - tolerance and entryLow <= supplyLevel + tolerance
    
    retest2 = not na(supplyLevel2) and (entryHigh >= supplyLevel2 - tolerance and entryHigh <= supplyLevel2 + tolerance or entryClose >= supplyLevel2 - tolerance and entryClose <= supplyLevel2 + tolerance or entryLow >= supplyLevel2 - tolerance and entryLow <= supplyLevel2 + tolerance)
    
    retest3 = not na(supplyLevel3) and (entryHigh >= supplyLevel3 - tolerance and entryHigh <= supplyLevel3 + tolerance or entryClose >= supplyLevel3 - tolerance and entryClose <= supplyLevel3 + tolerance or entryLow >= supplyLevel3 - tolerance and entryLow <= supplyLevel3 + tolerance)
    
    if retest1 or retest1b or retest1c or retest2 or retest3
        shortSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 + stopLossPercent / 100)
        tpPrice := entryPrice * (1 - takeProfitPercent / 100)

// Validate Risk:Reward ratio
if longSignal or shortSignal
    risk = math.abs(entryPrice - slPrice)
    reward = math.abs(tpPrice - entryPrice)
    rr = reward / risk
    
    if rr < minRiskReward
        longSignal := false
        shortSignal := false

// --- VISUALIZATION ---
plotshape(longSignal, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title="LONG Signal")
plotshape(shortSignal, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="SHORT Signal")

// Plot trend
plot(currentTrend == "UP" ? low : na, color=color.new(color.green, 80), style=plot.style_stepline, linewidth=2, title="Uptrend")
plot(currentTrend == "DOWN" ? high : na, color=color.new(color.red, 80), style=plot.style_stepline, linewidth=2, title="Downtrend")

// --- TEST ALERT (for webhook verification) ---
// Send test alert if test mode is enabled
if enableTestMode and barstate.isconfirmed
    testPayload = '{"signal":"TEST","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(close, "#.##") + ',"sl_price":' + str.tostring(close * 0.995, "#.##") + ',"tp_price":' + str.tostring(close * 1.01, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '","test":true'
    
    if webhookSecret != ""
        testPayload := testPayload + ',"secret":"' + webhookSecret + '"'
    
    testPayload := testPayload + '}'
    
    alert(testPayload, alert.freq_once_per_bar)

// --- ALERT LOGIC ---
// Generate webhook payload when signal is detected
if longSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"LONG","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("LONG", strategy.long, comment="LONG")

if shortSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"SHORT","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("SHORT", strategy.short, comment="SHORT")

// --- STRATEGY EXIT (for backtesting) ---
if strategy.position_size > 0
    strategy.exit("LONG EXIT", "LONG", stop=slPrice, limit=tpPrice)

if strategy.position_size < 0
    strategy.exit("SHORT EXIT", "SHORT", stop=slPrice, limit=tpPrice)

// --- VISUALIZE ZONES ---
// Draw most recent supply zone
if array.size(supplyZones) > 0
    supplyLevel = array.get(supplyZones, array.size(supplyZones) - 1)
    line.new(bar_index - 50, supplyLevel, bar_index, supplyLevel, color=color.new(color.red, 70), width=2, style=line.style_dashed, extend=extend.right)

// Draw most recent demand zone
if array.size(demandZones) > 0
    demandLevel = array.get(demandZones, array.size(demandZones) - 1)
    line.new(bar_index - 50, demandLevel, bar_index, demandLevel, color=color.new(color.green, 70), width=2, style=line.style_dashed, extend=extend.right)

// --- TABLE INFO (with diagnostics) ---
if barstate.islast
    var table infoTable = table.new(position.top_right, 2, 9, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(infoTable, 0, 0, "Trend", text_color=color.black)
    table.cell(infoTable, 1, 0, currentTrend, text_color=currentTrend == "UP" ? color.green : currentTrend == "DOWN" ? color.red : color.gray)
    table.cell(infoTable, 0, 1, "Entry TF", text_color=color.black)
    table.cell(infoTable, 1, 1, entryTimeframe, text_color=color.black)
    table.cell(infoTable, 0, 2, "SL %", text_color=color.black)
    table.cell(infoTable, 1, 2, str.tostring(stopLossPercent) + "%", text_color=color.black)
    table.cell(infoTable, 0, 3, "TP %", text_color=color.black)
    table.cell(infoTable, 1, 3, str.tostring(takeProfitPercent) + "%", text_color=color.black)
    table.cell(infoTable, 0, 4, "Supply Zones", text_color=color.black)
    table.cell(infoTable, 1, 4, str.tostring(array.size(supplyZones)), text_color=color.red)
    table.cell(infoTable, 0, 5, "Demand Zones", text_color=color.black)
    table.cell(infoTable, 1, 5, str.tostring(array.size(demandZones)), text_color=color.green)
    
    // Diagnostic: Show distance to nearest zone
    if currentTrend == "DOWN" and array.size(supplyZones) > 0
        nearestSupply = array.get(supplyZones, array.size(supplyZones) - 1)
        distanceToZone = math.abs(close - nearestSupply) / close * 100
        table.cell(infoTable, 0, 6, "Dist to Supply", text_color=color.black)
        table.cell(infoTable, 1, 6, str.tostring(distanceToZone, "#.##") + "%", text_color=distanceToZone <= 0.3 ? color.green : color.gray)
    else if currentTrend == "UP" and array.size(demandZones) > 0
        nearestDemand = array.get(demandZones, array.size(demandZones) - 1)
        distanceToZone = math.abs(close - nearestDemand) / close * 100
        table.cell(infoTable, 0, 6, "Dist to Demand", text_color=color.black)
        table.cell(infoTable, 1, 6, str.tostring(distanceToZone, "#.##") + "%", text_color=distanceToZone <= 0.3 ? color.green : color.gray)
    else
        table.cell(infoTable, 0, 6, "Dist to Zone", text_color=color.black)
        table.cell(infoTable, 1, 6, "N/A", text_color=color.gray)
    
    // Show if signal would be generated (before R:R check)
    table.cell(infoTable, 0, 7, "Signal Ready", text_color=color.black)
    signalReady = longSignal or shortSignal
    table.cell(infoTable, 1, 7, signalReady ? "YES" : "NO", text_color=signalReady ? color.green : color.gray)
    
    // Show R:R if signal would be generated
    if signalReady and not na(entryPrice) and not na(slPrice) and not na(tpPrice)
        risk = math.abs(entryPrice - slPrice)
        reward = math.abs(tpPrice - entryPrice)
        rr = reward / risk
        table.cell(infoTable, 0, 8, "R:R Ratio", text_color=color.black)
        table.cell(infoTable, 1, 8, str.tostring(rr, "#.##"), text_color=rr >= minRiskReward ? color.green : color.red)
    else
        table.cell(infoTable, 0, 8, "R:R Ratio", text_color=color.black)
        table.cell(infoTable, 1, 8, "-", text_color=color.gray)

