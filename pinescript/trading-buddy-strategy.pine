//@version=5
strategy("Trading Buddy - Bitcoin Day Trading", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// ============================================================================
// TRADING BUDDY - PINE SCRIPT STRATEGY
// ============================================================================
// This script generates trading signals and sends them to the Trading Buddy
// webhook endpoint via TradingView alerts.
//
// SETUP INSTRUCTIONS:
// 1. Add this script to TradingView chart (BTC-PERPETUAL recommended)
// 2. Configure alerts: Right-click chart > Add Alert
// 3. Condition: "Any alert() function call"
// 4. Webhook URL: https://your-vercel-app.vercel.app/api/webhook
// 5. Message: Use the JSON payload format below (see alert() calls)
// 6. Enable "Webhook URL" option
//
// ============================================================================

// --- INPUTS ---
// Timeframe settings
trendTimeframe = input.timeframe("15", "Trend Timeframe", group="Strategy Settings")
entryTimeframe = input.timeframe("5", "Entry Timeframe", group="Strategy Settings")

// Risk management
stopLossPercent = input.float(0.5, "Stop Loss %", minval=0.1, maxval=2.0, step=0.1, group="Risk Management")
takeProfitPercent = input.float(1.0, "Take Profit %", minval=0.5, maxval=5.0, step=0.1, group="Risk Management")
minRiskReward = input.float(2.0, "Min Risk:Reward Ratio", minval=1.0, maxval=5.0, step=0.1, group="Risk Management")

// Supply/Demand zone settings
zoneLookback = input.int(50, "Zone Lookback Periods", minval=20, maxval=200, group="Zone Detection")
zoneStrength = input.int(3, "Zone Strength (touches)", minval=2, maxval=10, group="Zone Detection")

// Webhook secret (optional, for security)
webhookSecret = input.string("", "Webhook Secret (optional)", group="Webhook Settings")

// Test mode (for testing webhook without real signals)
enableTestMode = input.bool(false, "Enable Test Mode", group="Webhook Settings", tooltip="When enabled, sends a test alert every bar to verify webhook is working")

// --- VARIABLES ---
var string currentTrend = "NEUTRAL"
var float supplyZoneHigh = na
var float supplyZoneLow = na
var float demandZoneHigh = na
var float demandZoneLow = na

// --- TREND DETECTION (15m timeframe) ---
[trendEMA, trendSMA] = request.security(syminfo.tickerid, trendTimeframe, [ta.ema(close, 20), ta.sma(close, 50)], lookahead=barmerge.lookahead_off)

trendUp = trendEMA > trendSMA and close > trendEMA
trendDown = trendEMA < trendSMA and close < trendEMA

if trendUp
    currentTrend := "UP"
else if trendDown
    currentTrend := "DOWN"
else
    currentTrend := "NEUTRAL"

// --- SUPPLY/DEMAND ZONE DETECTION ---
// Improved zone detection that keeps zones longer and detects more patterns
var float[] supplyZones = array.new<float>()
var float[] demandZones = array.new<float>()

// Detect supply zones (resistance) - price rejected from high
// Multiple patterns to catch more zones
if high[1] > high[2] and high[1] > high and close < open
    // Strong rejection pattern
    array.push(supplyZones, high[1])
else if high[1] > high and close < open[1] and close < open
    // Rejection with bearish close
    array.push(supplyZones, high[1])
else if high[1] > ta.highest(high, 5) and close < open
    // New high rejection
    array.push(supplyZones, high[1])

// Keep more zones (increased from 10 to 20)
if array.size(supplyZones) > 20
    array.shift(supplyZones)

// Detect demand zones (support) - price rejected from low
// Multiple patterns to catch more zones
if low[1] < low[2] and low[1] < low and close > open
    // Strong bounce pattern
    array.push(demandZones, low[1])
else if low[1] < low and close > open[1] and close > open
    // Bounce with bullish close
    array.push(demandZones, low[1])
else if low[1] < ta.lowest(low, 5) and close > open
    // New low bounce
    array.push(demandZones, low[1])

// Keep more zones (increased from 10 to 20)
if array.size(demandZones) > 20
    array.shift(demandZones)

// --- ENTRY SIGNAL DETECTION ---
// Look for retest of supply/demand zones on 5m timeframe
[entryClose, entryHigh, entryLow] = request.security(syminfo.tickerid, entryTimeframe, [close, high, low], lookahead=barmerge.lookahead_off)

bool longSignal = false
bool shortSignal = false
float entryPrice = na
float slPrice = na
float tpPrice = na

// LONG signal: retest of demand zone in uptrend
// Check last 3 demand zones for retest (balanced approach)
if currentTrend == "UP" and array.size(demandZones) > 0
    // Check most recent zone
    demandLevel = array.get(demandZones, array.size(demandZones) - 1)
    tolerance = demandLevel * 0.003 // 0.3% tolerance (balanced)
    
    // Also check 2nd and 3rd most recent zones
    demandLevel2 = array.size(demandZones) >= 2 ? array.get(demandZones, array.size(demandZones) - 2) : na
    demandLevel3 = array.size(demandZones) >= 3 ? array.get(demandZones, array.size(demandZones) - 3) : na
    
    // Check if price touches zone (using low, close, or high)
    retest1 = entryLow <= demandLevel + tolerance and entryLow >= demandLevel - tolerance
    retest1b = entryClose <= demandLevel + tolerance and entryClose >= demandLevel - tolerance
    retest1c = entryHigh <= demandLevel + tolerance and entryHigh >= demandLevel - tolerance
    
    retest2 = not na(demandLevel2) and (entryLow <= demandLevel2 + tolerance and entryLow >= demandLevel2 - tolerance or entryClose <= demandLevel2 + tolerance and entryClose >= demandLevel2 - tolerance or entryHigh <= demandLevel2 + tolerance and entryHigh >= demandLevel2 - tolerance)
    
    retest3 = not na(demandLevel3) and (entryLow <= demandLevel3 + tolerance and entryLow >= demandLevel3 - tolerance or entryClose <= demandLevel3 + tolerance and entryClose >= demandLevel3 - tolerance or entryHigh <= demandLevel3 + tolerance and entryHigh >= demandLevel3 - tolerance)
    
    if retest1 or retest1b or retest1c or retest2 or retest3
        longSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 - stopLossPercent / 100)
        tpPrice := entryPrice * (1 + takeProfitPercent / 100)

// SHORT signal: retest of supply zone in downtrend
// Check last 3 supply zones for retest (balanced approach)
if currentTrend == "DOWN" and array.size(supplyZones) > 0
    // Check most recent zone
    supplyLevel = array.get(supplyZones, array.size(supplyZones) - 1)
    tolerance = supplyLevel * 0.003 // 0.3% tolerance (balanced)
    
    // Also check 2nd and 3rd most recent zones
    supplyLevel2 = array.size(supplyZones) >= 2 ? array.get(supplyZones, array.size(supplyZones) - 2) : na
    supplyLevel3 = array.size(supplyZones) >= 3 ? array.get(supplyZones, array.size(supplyZones) - 3) : na
    
    // Check if price touches zone (using high, close, or low)
    retest1 = entryHigh >= supplyLevel - tolerance and entryHigh <= supplyLevel + tolerance
    retest1b = entryClose >= supplyLevel - tolerance and entryClose <= supplyLevel + tolerance
    retest1c = entryLow >= supplyLevel - tolerance and entryLow <= supplyLevel + tolerance
    
    retest2 = not na(supplyLevel2) and (entryHigh >= supplyLevel2 - tolerance and entryHigh <= supplyLevel2 + tolerance or entryClose >= supplyLevel2 - tolerance and entryClose <= supplyLevel2 + tolerance or entryLow >= supplyLevel2 - tolerance and entryLow <= supplyLevel2 + tolerance)
    
    retest3 = not na(supplyLevel3) and (entryHigh >= supplyLevel3 - tolerance and entryHigh <= supplyLevel3 + tolerance or entryClose >= supplyLevel3 - tolerance and entryClose <= supplyLevel3 + tolerance or entryLow >= supplyLevel3 - tolerance and entryLow <= supplyLevel3 + tolerance)
    
    if retest1 or retest1b or retest1c or retest2 or retest3
        shortSignal := true
        entryPrice := entryClose
        slPrice := entryPrice * (1 + stopLossPercent / 100)
        tpPrice := entryPrice * (1 - takeProfitPercent / 100)

// Validate Risk:Reward ratio
if longSignal or shortSignal
    risk = math.abs(entryPrice - slPrice)
    reward = math.abs(tpPrice - entryPrice)
    rr = reward / risk
    
    if rr < minRiskReward
        longSignal := false
        shortSignal := false

// --- VISUALIZATION ---
plotshape(longSignal, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title="LONG Signal")
plotshape(shortSignal, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="SHORT Signal")

// Plot trend
plot(currentTrend == "UP" ? low : na, color=color.new(color.green, 80), style=plot.style_stepline, linewidth=2, title="Uptrend")
plot(currentTrend == "DOWN" ? high : na, color=color.new(color.red, 80), style=plot.style_stepline, linewidth=2, title="Downtrend")

// --- TEST ALERT (for webhook verification) ---
// Send test alert if test mode is enabled
if enableTestMode and barstate.isconfirmed
    testPayload = '{"signal":"TEST","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(close, "#.##") + ',"sl_price":' + str.tostring(close * 0.995, "#.##") + ',"tp_price":' + str.tostring(close * 1.01, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '","test":true'
    
    if webhookSecret != ""
        testPayload := testPayload + ',"secret":"' + webhookSecret + '"'
    
    testPayload := testPayload + '}'
    
    alert(testPayload, alert.freq_once_per_bar)

// --- ALERT LOGIC ---
// Generate webhook payload when signal is detected
if longSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"LONG","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("LONG", strategy.long, comment="LONG")

if shortSignal and barstate.isconfirmed
    // Build JSON payload for webhook
    payload = '{"signal":"SHORT","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"sl_price":' + str.tostring(slPrice, "#.##") + ',"tp_price":' + str.tostring(tpPrice, "#.##") + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","trend":"' + currentTrend + '"'
    
    if webhookSecret != ""
        payload := payload + ',"secret":"' + webhookSecret + '"'
    
    payload := payload + '}'
    
    alert(payload, alert.freq_once_per_bar)
    
    // Strategy backtesting (optional)
    strategy.entry("SHORT", strategy.short, comment="SHORT")

// --- TRADE EXIT DETECTION & VALIDATION ALERTS ---
// Track the last entry signal to detect exits
var float lastEntryPrice = na
var float lastSLPrice = na
var float lastTPPrice = na
var string lastSignalType = na
var int lastEntryBar = na
var bool exitAlertSent = false

// Store entry data when signal is generated
// Also store when strategy.entry is called (for strategy engine tracking)
if (longSignal or shortSignal) and barstate.isconfirmed
    // Update tracking variables (new signal always overwrites, which is OK for paper trading)
    lastEntryPrice := entryPrice
    lastSLPrice := slPrice
    lastTPPrice := tpPrice
    lastSignalType := longSignal ? "LONG" : "SHORT"
    lastEntryBar := bar_index
    exitAlertSent := false // Reset exit flag for new trade

// Also track when strategy actually enters (in case signal and strategy entry differ)
if strategy.position_size != 0 and na(lastEntryPrice)
    // Strategy has a position but we don't have tracking - try to get from strategy
    if strategy.position_size > 0
        // LONG position
        lastEntryPrice := strategy.position_avg_price
        lastSignalType := "LONG"
    else if strategy.position_size < 0
        // SHORT position
        lastEntryPrice := strategy.position_avg_price
        lastSignalType := "SHORT"
    
    // Try to get SL/TP from current signal prices (if available)
    if not na(entryPrice) and not na(slPrice) and not na(tpPrice)
        lastSLPrice := slPrice
        lastTPPrice := tpPrice
        lastEntryBar := bar_index
        exitAlertSent := false

// Detect if TP or SL was hit (for validation alerts)
// Check every bar, including checking if TP/SL was hit on previous bars since entry
if not na(lastEntryPrice) and not na(lastSLPrice) and not na(lastTPPrice) and not exitAlertSent
    bool tpHit = false
    bool slHit = false
    float exitPrice = na
    string exitReason = ""
    
    // Calculate how many bars since entry
    barsSinceEntry = bar_index - lastEntryBar
    
    // Limit lookback to avoid historical buffer errors (max 500 bars, but be safe with 100)
    // Also ensure we don't request more than available
    lookbackBars = math.min(barsSinceEntry + 1, 100)
    
    // Only check if we have enough bars and lookback is reasonable
    if lookbackBars > 0 and lookbackBars <= 100
        if lastSignalType == "LONG"
            // LONG: Check if highest high since entry >= TP, or lowest low <= SL
            // Use ta.highest/lowest with safe lookback
            highestSinceEntry = ta.highest(high, lookbackBars)
            lowestSinceEntry = ta.lowest(low, lookbackBars)
            
            // Check TP first (priority)
            if highestSinceEntry >= lastTPPrice
                tpHit := true
                exitPrice := lastTPPrice
                exitReason := "TAKE_PROFIT"
            // Then check SL
            else if lowestSinceEntry <= lastSLPrice
                slHit := true
                exitPrice := lastSLPrice
                exitReason := "STOP_LOSS"
        else if lastSignalType == "SHORT"
            // SHORT: Check if lowest low since entry <= TP, or highest high >= SL
            highestSinceEntry = ta.highest(high, lookbackBars)
            lowestSinceEntry = ta.lowest(low, lookbackBars)
            
            // Check TP first (priority)
            if lowestSinceEntry <= lastTPPrice
                tpHit := true
                exitPrice := lastTPPrice
                exitReason := "TAKE_PROFIT"
            // Then check SL
            else if highestSinceEntry >= lastSLPrice
                slHit := true
                exitPrice := lastSLPrice
                exitReason := "STOP_LOSS"
    
    // Send validation alert when TP or SL is hit
    if (tpHit or slHit) and barstate.isconfirmed
        string validationPayload = '{"signal":"TRADE_EXIT","type":"' + exitReason + '","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(lastEntryPrice, "#.##") + ',"sl_price":' + str.tostring(lastSLPrice, "#.##") + ',"tp_price":' + str.tostring(lastTPPrice, "#.##") + ',"exit_price":' + str.tostring(exitPrice, "#.##") + ',"entry_signal":"' + lastSignalType + '","entry_bar":' + str.tostring(lastEntryBar) + ',"exit_bar":' + str.tostring(bar_index) + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '"'
        
        if webhookSecret != ""
            validationPayload := validationPayload + ',"secret":"' + webhookSecret + '"'
        
        validationPayload := validationPayload + '}'
        
        alert(validationPayload, alert.freq_once_per_bar)
        
        // Mark that exit alert was sent (prevent duplicate alerts)
        // Keep tracking variables until new signal comes in (for reference)
        exitAlertSent := true

// --- STRATEGY EXIT (for backtesting) ---
if strategy.position_size > 0
    strategy.exit("LONG EXIT", "LONG", stop=slPrice, limit=tpPrice)

if strategy.position_size < 0
    strategy.exit("SHORT EXIT", "SHORT", stop=slPrice, limit=tpPrice)

// --- STRATEGY TRADE EXIT DETECTION (uses TradingView's strategy engine) ---
// This is more reliable than manual detection because TradingView knows exactly when TP/SL is hit
var int lastClosedTradeId = -1

// Also check if strategy position was closed (position_size went to 0)
var float lastPositionSize = 0.0
if strategy.position_size == 0 and lastPositionSize != 0
    // Position was just closed - this is more reliable than waiting for closedtrades
    // Get the most recent closed trade if available
    if strategy.closedtrades > 0
        closedTradeId = strategy.closedtrades - 1
        
        // Get exit information from the closed trade
        exitPrice = strategy.closedtrades.exit_price(closedTradeId)
        exitTime = strategy.closedtrades.exit_time(closedTradeId)
        entryPriceFromStrategy = strategy.closedtrades.entry_price(closedTradeId)
        entryTime = strategy.closedtrades.entry_time(closedTradeId)
        entrySignalFromStrategy = strategy.closedtrades.entry_id(closedTradeId) // "LONG" or "SHORT"
        
        // Determine exit type based on profit/loss
        string exitTypeFromStrategy = "UNKNOWN"
        if entrySignalFromStrategy == "LONG"
            if exitPrice >= entryPriceFromStrategy
                exitTypeFromStrategy := "TAKE_PROFIT"
            else
                exitTypeFromStrategy := "STOP_LOSS"
        else if entrySignalFromStrategy == "SHORT"
            if exitPrice <= entryPriceFromStrategy
                exitTypeFromStrategy := "TAKE_PROFIT"
            else
                exitTypeFromStrategy := "STOP_LOSS"
        
        // Send exit alert
        if exitPrice > 0 and entryPriceFromStrategy > 0
            string strategyExitPayload = '{"signal":"TRADE_EXIT","type":"' + exitTypeFromStrategy + '","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPriceFromStrategy, "#.##") + ',"exit_price":' + str.tostring(exitPrice, "#.##") + ',"entry_signal":"' + entrySignalFromStrategy + '","entry_time":' + str.tostring(entryTime) + ',"exit_time":' + str.tostring(exitTime) + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","source":"strategy_engine"'
            
            if webhookSecret != ""
                strategyExitPayload := strategyExitPayload + ',"secret":"' + webhookSecret + '"'
            
            strategyExitPayload := strategyExitPayload + '}'
            
            alert(strategyExitPayload, alert.freq_once_per_bar)
            
            // Reset tracking
            lastEntryPrice := na
            lastSLPrice := na
            lastTPPrice := na
            lastSignalType := na
            exitAlertSent := true

// Update last position size
lastPositionSize := strategy.position_size

// Check if a new trade was closed (strategy.closedtrades increased)
if strategy.closedtrades > lastClosedTradeId
    // Get the most recent closed trade
    closedTradeId = strategy.closedtrades - 1
    
    // Get exit information from the closed trade
    exitPrice = strategy.closedtrades.exit_price(closedTradeId)
    exitTime = strategy.closedtrades.exit_time(closedTradeId)
    entryPrice = strategy.closedtrades.entry_price(closedTradeId)
    entryTime = strategy.closedtrades.entry_time(closedTradeId)
    entrySignal = strategy.closedtrades.entry_id(closedTradeId) // "LONG" or "SHORT"
    exitReason = strategy.closedtrades.exit_id(closedTradeId) // "LONG EXIT" or "SHORT EXIT"
    
    // Determine exit type (TP or SL) based on exit reason and prices
    // For LONG: if exit was at TP, exitPrice should be close to TP; if SL, close to SL
    // For SHORT: if exit was at TP, exitPrice should be close to TP; if SL, close to SL
    string exitType = "UNKNOWN"
    
    // We need to get the TP and SL from when the trade was entered
    // Since we don't have that stored, we'll use a heuristic:
    // If exit was profitable, it's likely TP; if loss, likely SL
    // But we can also check the exit reason string
    if str.contains(exitReason, "EXIT")
        // Try to determine from entry signal
        if entrySignal == "LONG"
            // For LONG: TP is above entry, SL is below entry
            if exitPrice >= entryPrice
                exitType := "TAKE_PROFIT" // Likely TP (profitable)
            else
                exitType := "STOP_LOSS" // Likely SL (loss)
        else if entrySignal == "SHORT"
            // For SHORT: TP is below entry, SL is above entry
            if exitPrice <= entryPrice
                exitType := "TAKE_PROFIT" // Likely TP (profitable)
            else
                exitType := "STOP_LOSS" // Likely SL (loss)
    
    // Send exit alert with strategy trade data
    if exitPrice > 0 and entryPrice > 0
        string strategyExitPayload = '{"signal":"TRADE_EXIT","type":"' + exitType + '","symbol":"' + syminfo.ticker + '","entry_price":' + str.tostring(entryPrice, "#.##") + ',"exit_price":' + str.tostring(exitPrice, "#.##") + ',"entry_signal":"' + entrySignal + '","entry_time":' + str.tostring(entryTime) + ',"exit_time":' + str.tostring(exitTime) + ',"timeframe":"' + str.tostring(timeframe.period) + '","time":"' + str.tostring(time) + '","source":"strategy_engine"'
        
        if webhookSecret != ""
            strategyExitPayload := strategyExitPayload + ',"secret":"' + webhookSecret + '"'
        
        strategyExitPayload := strategyExitPayload + '}'
        
        alert(strategyExitPayload, alert.freq_once_per_bar)
        
        // Update last closed trade ID
        lastClosedTradeId := strategy.closedtrades

// --- VISUALIZE ZONES ---
// Draw most recent supply zone
if array.size(supplyZones) > 0
    supplyLevel = array.get(supplyZones, array.size(supplyZones) - 1)
    line.new(bar_index - 50, supplyLevel, bar_index, supplyLevel, color=color.new(color.red, 70), width=2, style=line.style_dashed, extend=extend.right)

// Draw most recent demand zone
if array.size(demandZones) > 0
    demandLevel = array.get(demandZones, array.size(demandZones) - 1)
    line.new(bar_index - 50, demandLevel, bar_index, demandLevel, color=color.new(color.green, 70), width=2, style=line.style_dashed, extend=extend.right)

// --- TABLE INFO (with diagnostics) ---
if barstate.islast
    var table infoTable = table.new(position.top_right, 2, 9, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(infoTable, 0, 0, "Trend", text_color=color.black)
    table.cell(infoTable, 1, 0, currentTrend, text_color=currentTrend == "UP" ? color.green : currentTrend == "DOWN" ? color.red : color.gray)
    table.cell(infoTable, 0, 1, "Entry TF", text_color=color.black)
    table.cell(infoTable, 1, 1, entryTimeframe, text_color=color.black)
    table.cell(infoTable, 0, 2, "SL %", text_color=color.black)
    table.cell(infoTable, 1, 2, str.tostring(stopLossPercent) + "%", text_color=color.black)
    table.cell(infoTable, 0, 3, "TP %", text_color=color.black)
    table.cell(infoTable, 1, 3, str.tostring(takeProfitPercent) + "%", text_color=color.black)
    table.cell(infoTable, 0, 4, "Supply Zones", text_color=color.black)
    table.cell(infoTable, 1, 4, str.tostring(array.size(supplyZones)), text_color=color.red)
    table.cell(infoTable, 0, 5, "Demand Zones", text_color=color.black)
    table.cell(infoTable, 1, 5, str.tostring(array.size(demandZones)), text_color=color.green)
    
    // Diagnostic: Show distance to nearest zone
    if currentTrend == "DOWN" and array.size(supplyZones) > 0
        nearestSupply = array.get(supplyZones, array.size(supplyZones) - 1)
        distanceToZone = math.abs(close - nearestSupply) / close * 100
        table.cell(infoTable, 0, 6, "Dist to Supply", text_color=color.black)
        table.cell(infoTable, 1, 6, str.tostring(distanceToZone, "#.##") + "%", text_color=distanceToZone <= 0.3 ? color.green : color.gray)
    else if currentTrend == "UP" and array.size(demandZones) > 0
        nearestDemand = array.get(demandZones, array.size(demandZones) - 1)
        distanceToZone = math.abs(close - nearestDemand) / close * 100
        table.cell(infoTable, 0, 6, "Dist to Demand", text_color=color.black)
        table.cell(infoTable, 1, 6, str.tostring(distanceToZone, "#.##") + "%", text_color=distanceToZone <= 0.3 ? color.green : color.gray)
    else
        table.cell(infoTable, 0, 6, "Dist to Zone", text_color=color.black)
        table.cell(infoTable, 1, 6, "N/A", text_color=color.gray)
    
    // Show if signal would be generated (before R:R check)
    table.cell(infoTable, 0, 7, "Signal Ready", text_color=color.black)
    signalReady = longSignal or shortSignal
    table.cell(infoTable, 1, 7, signalReady ? "YES" : "NO", text_color=signalReady ? color.green : color.gray)
    
    // Show R:R if signal would be generated
    if signalReady and not na(entryPrice) and not na(slPrice) and not na(tpPrice)
        risk = math.abs(entryPrice - slPrice)
        reward = math.abs(tpPrice - entryPrice)
        rr = reward / risk
        table.cell(infoTable, 0, 8, "R:R Ratio", text_color=color.black)
        table.cell(infoTable, 1, 8, str.tostring(rr, "#.##"), text_color=rr >= minRiskReward ? color.green : color.red)
    else
        table.cell(infoTable, 0, 8, "R:R Ratio", text_color=color.black)
        table.cell(infoTable, 1, 8, "-", text_color=color.gray)

